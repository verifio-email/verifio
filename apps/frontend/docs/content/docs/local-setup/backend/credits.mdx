---
title: Credits Service
description: Credit management with atomic operations, monthly reset, and billing integration.
---

import { Callout } from 'fumadocs-ui/components/callout'

# Credits Service

Manages credit balances, usage tracking, and monthly billing cycles for email verification operations.

## Overview

| Property | Value |
|----------|-------|
| **Location** | `apps/backend/credits` |
| **Framework** | ElysiaJS |
| **Port** | 8005 |
| **Route Prefix** | `/api/credits` |

## What It Does

The Credits service handles:

- **Credit Tracking** - Monitors credit usage in real-time
- **Atomic Operations** - Prevents double-spending with atomic check-and-deduct
- **Monthly Reset** - Automatically resets credits each billing period
- **Usage History** - Archives past billing periods
- **Balance Checks** - Validates sufficient credits before operations
- **Billing Integration** - Prepares data for billing systems

## Starting the Service

```bash
bun run be:credits:dev
```

## Environment Variables

Create a `.env` file in `apps/backend/credits/`:

```bash
# Server Configuration
PORT=8005
BASE_URL=https://local.verifio.email

# Database
PG_URL=postgresql://verifio:verifio123@localhost:5432/verifio

# Cache (Redis)
REDIS_URL=redis://:verifio123@localhost:6379

# Credit Settings
DEFAULT_CREDIT_LIMIT=3000
CREDIT_RESET_PERIOD=monthly
```

### Environment Variables Details

| Variable | Required | Default | Description |
|----------|----------|---------|-------------|
| `PORT` | No | 8005 | Port to run the service on |
| `BASE_URL` | Yes | - | Base URL for service-to-service calls |
| `PG_URL` | Yes | - | PostgreSQL connection string |
| `REDIS_URL` | Yes | - | Redis connection string for caching |
| `DEFAULT_CREDIT_LIMIT` | No | 3000 | Default monthly credit limit per organization |
| `CREDIT_RESET_PERIOD` | No | `monthly` | Reset period (monthly, yearly) |

## API Endpoints

<Callout type="info">
  API reference is auto-generated from OpenAPI specs. See the **[Credits API Reference](/docs/api-reference)** for detailed endpoint documentation.
</Callout>

### Main Endpoints

| Route | Method | Description | Auth Required |
|-------|--------|-------------|---------------|
| `/api/credits/v1/status` | POST | Get current credit status | Session |
| `/api/credits/v1/history` | GET | Get credit usage history | Session |
| `/api/credits/v1/available-credits` | POST | Check if enough credits available | Session or Internal |
| `/api/credits/v1/deduct` | POST | Atomically deduct credits | Session or Internal |
| `/api/credits/health` | GET | Health check | No |

<Callout type="warn">
  The `available-credits` and `deduct` endpoints are marked as **internal** but are called by other backend services using cookie forwarding.
</Callout>

## Credit Management Logic

### Lazy Reset Pattern

Credits use a "lazy reset" approach:

1. **First Access Check** - On first credit operation of the period, check if reset is needed
2. **Archive Old Period** - Copy current usage to `creditHistory` table
3. **Reset Counters** - Set `creditsUsed` to 0
4. **Update Period** - Set new `periodStart` and `periodEnd`

```typescript
// Pseudo-code
async function ensureCurrentPeriod(orgId: string) {
  const current = await getCurrentCredits(orgId);

  if (new Date() > current.periodEnd) {
    // Archive to history
    await archiveToHistory(current);

    // Reset for new period
    await resetCredits(orgId);
  }
}
```

### Atomic Deduction

Prevents double-spending with a single atomic SQL operation:

```sql
UPDATE org_credits
SET credits_used = credits_used + $1
WHERE id = $2
  AND credit_limit - credits_used >= $1
RETURNING *;
```

- **Returns**: Row if successful, null if insufficient credits
- **Guarantee**: No race conditions, no double-spending
- **Failure**: Returns null if insufficient credits

## Code Patterns

### Checking Credit Status

```typescript
const response = await fetch('https://local.verifio.email/api/credits/v1/status', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json',
  },
});

const {
  used,
  remaining,
  limit,
  periodStart,
  periodEnd,
} = await response.json();

console.log(`Used ${used} of ${limit} credits`);
console.log(`${remaining} credits remaining`);
```

### Checking Available Credits (Before Operation)

```typescript
// From verify service - check before verification
const creditsResponse = await fetch(`${BASE_URL}/api/credits/v1/available-credits`, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Cookie': headers.cookie,  // Forward user session
  },
  body: JSON.stringify({
    amount: emailCount,
  }),
});

if (!creditsResponse.ok) {
  return { error: 'Insufficient credits' };
}
```

### Deducting Credits (After Operation)

```typescript
// From verify service - deduct after completion
const deductResponse = await fetch(`${BASE_URL}/api/credits/v1/deduct`, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'Cookie': headers.cookie,  // Forward user session
  },
  body: JSON.stringify({
    amount: actualCreditsUsed,
  }),
});

if (!deductResponse.ok) {
  // This should rarely happen if we checked first
  console.error('Failed to deduct credits');
}
```

### Getting Credit History

```typescript
const response = await fetch('https://local.verifio.email/api/credits/v1/history', {
  credentials: 'include',
});

const { history } = await response.json();

history.forEach(period => {
  console.log(`${period.periodStart} to ${period.periodEnd}`);
  console.log(`Used: ${period.creditsUsed} of ${period.creditLimit}`);
});
```

## Database Tables Used

| Table | Purpose |
|-------|---------|
| `orgCredits` | Current billing period (1:1 per organization) |
| `creditHistory` | Archived past billing periods |

### Schema: `orgCredits`

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Primary key |
| `organizationId` | string | Organization (unique) |
| `creditLimit` | number | Maximum credits per period |
| `creditsUsed` | number | Credits used in current period |
| `periodStart` | Date | Current period start |
| `periodEnd` | Date | Current period end |

### Schema: `creditHistory`

| Field | Type | Description |
|-------|------|-------------|
| `id` | string | Primary key |
| `organizationId` | string | Organization |
| `creditLimit` | number | Limit for that period |
| `creditsUsed` | number | Credits used in that period |
| `periodStart` | Date | Period start |
| `periodEnd` | Date | Period end |
| `archivedAt` | Date | When this record was archived |

## Inter-Service Communication

The Credits service is called by:

### Verify Service

```typescript
// Before verification
POST /api/credits/v1/available-credits
{
  "amount": 100  // Check if 100 credits available
}

// After verification
POST /api/credits/v1/deduct
{
  "amount": 95  // Deduct 95 credits (actual usage)
}
```

<Callout type="info">
  **Best Practice**: Always check available credits before an operation, then deduct the actual amount used after completion. This accounts for variable usage (e.g., some emails failing early).
</Callout>

## Authentication

The Credits service supports:

- **Session Cookie** - For dashboard users viewing their status
- **Cookie Forwarding** - For internal service-to-service calls

## Credit Flow

### Single Email Verification

```
1. User requests verification → 2. Check available credits
                                              ↓
                                       Credits available?
                                       ↙           ↘
                                      Yes           No
                                       ↓             ↓
                              3. Verify email    4. Return error
                                       ↓
                              5. Deduct 1 credit
                                       ↓
                              6. Return result
```

### Bulk Verification

```
1. User uploads 1000 emails → 2. Check available credits
                                              ↓
                                       Credits available?
                                       ↙           ↘
                                      Yes           No
                                       ↓             ↓
                              3. Start job       4. Return error
                                       ↓
                              5. Process emails
                              (actual usage varies)
                                       ↓
                              6. Deduct actual credits
                              (e.g., 850 credits)
                                       ↓
                              7. Return results
```

## Billing Periods

### Monthly Reset (Default)

- **Period Start**: Day of month when organization was created
- **Period End**: One month from period start
- **Example**: Created on Jan 15 → Resets on Feb 15, Mar 15, etc.

### Custom Periods

You can configure custom reset periods:

```typescript
// Yearly reset
CREDIT_RESET_PERIOD=yearly

// Specific day of month
CREDIT_RESET_DAY=1  // Reset on 1st of every month
```

## Troubleshooting

### "Insufficient credits" error

- Check your credit status in the dashboard
- Verify the billing period hasn't ended
- Contact support if you believe this is an error

### Credits not resetting

- Verify the Credits service is running
- Check `periodEnd` in the `orgCredits` table
- Ensure lazy reset is triggered by making a credit operation

### Incorrect credit usage

- Check the `activityLogs` table for all credit deductions
- Verify actual usage matches expected usage
- Look for failed operations that still deducted credits

### "Double deduction" occurring

- Verify the atomic deduction query is being used
- Check for race conditions in credit operations
- Ensure operations are idempotent (use unique request IDs)

### Service won't start

- Check port 8005 is available: `lsof -i :8005`
- Verify PostgreSQL is running: `docker ps | grep postgres`
- Verify Redis is running: `docker ps | grep redis`
- Check `.env` file exists and is correct

### Database connection errors

```bash
# Test PostgreSQL connection
psql postgresql://verifio:verifio123@localhost:5432/verifio
```

- Verify `PG_URL` in `.env` matches Docker configuration
- Check PostgreSQL container is running

## Health Checks

```bash
# Overall service health
curl http://localhost:8005/api/credits/health

# Database connectivity
curl http://localhost:8005/api/credits/health/postgres

# Cache connectivity
curl http://localhost:8005/api/credits/health/redis
```

Expected response: `{"status":"ok"}`

## Performance Considerations

- **Atomic Operations**: Single SQL query prevents race conditions
- **Lazy Reset**: Avoids periodic cron jobs, resets on-demand
- **Database Indexes**: Indexed on `organizationId` for fast lookups
- **Caching**: Redis caches current credit status

## Security Considerations

- **Session Required**: All operations require valid user session
- **Organization Isolation**: Users can only access their own credits
- **Cookie Forwarding**: Internal calls must forward user cookies
- **Atomic Deduction**: Prevents double-spending attacks

## Default Limits

| Plan | Monthly Credits |
|------|----------------|
| Free | 3,000 |
| Starter | 10,000 |
| Pro | 50,000 |
| Enterprise | Custom |

<Callout type="info">
  Default limits can be overridden per organization in the database.
</Callout>

## Related Services

- **Verify Service** - Main consumer of credits
- **Auth Service** - Provides organization context
- **Logs Service** - Records all credit operations
- **Billing Integration** - Uses `creditHistory` for invoices

## OpenAPI Documentation

Interactive API documentation is available when the service is running:

```
http://localhost:8005/docs
```

<Callout type="info">
  For auto-generated API reference docs, see the **[API Reference](/docs/api-reference)** section.
</Callout>
