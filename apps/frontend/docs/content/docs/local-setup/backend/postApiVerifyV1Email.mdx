---
title: Verify Single Email
description: Complete guide to verifying a single email address using the Verifio API. Learn how to make your first API call, understand the response, and handle all edge cases.
---

import { Callout } from 'fumadocs-ui/components/callout'
import { Tabs, Tab } from 'fumadocs-ui/components/tabs'
import { Cards, Card } from "fumadocs-ui/components/card"
import { Steps, Step } from 'fumadocs-ui/components/steps'

# Verify Single Email API

The **Verify Single Email** endpoint allows you to verify one email address at a time and receive comprehensive verification results. This is the most commonly used endpoint for real-time email verification during user signups, form submissions, or any scenario where you need immediate validation.

## Quick Overview

| Property | Value |
|----------|-------|
| **Endpoint** | `POST /api/verify/v1/email` |
| **Rate Limit** | 2 requests/minute (unauthenticated) |
| **Authentication** | Optional (API Key recommended) |
| **Credits Cost** | 1 credit per verification |

---

## Before You Start

<Callout type="info">
  This guide assumes you have **no prior setup**. If you already have an API key, skip to [Step 3: Make Your First API Call](#step-3-make-your-first-api-call).
</Callout>

### What You'll Need

- A computer with internet access
- A terminal/command line (Terminal on Mac, Command Prompt/PowerShell on Windows, or any Linux terminal)
- cURL installed (comes pre-installed on most systems)
- Optionally: Node.js, Python, or any HTTP client

---

## Step-by-Step Guide

<Steps>

<Step>
### Step 1: Create a Verifio Account

1. Open your web browser and go to **[verifio.email](https://verifio.email)**
2. Click the **"Sign Up"** or **"Get Started"** button
3. Enter your email address and create a password (or sign up with Google/GitHub)
4. Check your email inbox for a verification email and click the confirmation link
5. You're now logged into your Verifio dashboard!

<Callout type="info">
  New accounts receive **100 free credits** to test the API. One credit = one email verification.
</Callout>
</Step>

<Step>
### Step 2: Get Your API Key

Your API key is like a password that proves your requests are authorized. Here's how to get one:

1. In your Verifio dashboard, click **"Settings"** in the left sidebar
2. Click on **"API Keys"** 
3. Click the **"Create API Key"** button
4. Give your key a descriptive name (e.g., "My First Integration")
5. **IMPORTANT:** Copy the API key immediately and save it somewhere safe!

<Callout type="warn">
  **Your API key is only shown once!** After you close the modal, you won't be able to see the full key again. Store it securely (e.g., in a password manager or `.env` file).
</Callout>

Your API key will look something like this:

```
vrf_sk_live_abc123xyz789...
```

The format is: `vrf_` prefix + type (`sk_live_` for production) + random characters.
</Step>

<Step>
### Step 3: Make Your First API Call

Now let's verify your first email! Choose your preferred method below:

<Tabs items={['cURL', 'Node.js', 'Python', 'Go', 'PHP']}>

<Tab value="cURL">
Open your terminal and run this command (replace `YOUR_API_KEY` with your actual key):

```bash
curl -X POST "https://verifio.email/api/verify/v1/email" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"email": "test@gmail.com"}'
```

**Breaking this down:**
- `-X POST` ‚Äî We're making a POST request
- `"https://verifio.email/api/verify/v1/email"` ‚Äî The API endpoint URL
- `-H "Authorization: Bearer YOUR_API_KEY"` ‚Äî Your authentication header
- `-H "Content-Type: application/json"` ‚Äî Tells the server we're sending JSON
- `-d '{"email": "test@gmail.com"}'` ‚Äî The JSON body with the email to verify
</Tab>

<Tab value="Node.js">
First, install the Verifio SDK:

```bash
npm install @verifio/email-verification
```

Then create a file called `verify-email.js`:

```javascript
import { Verifio } from '@verifio/email-verification';

// Initialize the client with your API key
const verifio = new Verifio({
  apiKey: 'YOUR_API_KEY'  // Replace with your actual key
});

// Verify an email
async function verifyEmail() {
  try {
    const result = await verifio.verify('test@gmail.com');
    
    console.log('Email:', result.email);
    console.log('State:', result.state);        // 'deliverable', 'undeliverable', 'risky', 'unknown'
    console.log('Score:', result.score);        // 0-100
    console.log('Reason:', result.reason);      // Why this verdict was given
    console.log('Full Result:', JSON.stringify(result, null, 2));
  } catch (error) {
    console.error('Verification failed:', error.message);
  }
}

verifyEmail();
```

Run it:

```bash
node verify-email.js
```
</Tab>

<Tab value="Python">
First, install the Verifio SDK:

```bash
pip install verifio
```

Then create a file called `verify_email.py`:

```python
from verifio import Verifio

# Initialize the client with your API key
client = Verifio(api_key='YOUR_API_KEY')  # Replace with your actual key

# Verify an email
try:
    result = client.verify('test@gmail.com')
    
    print(f"Email: {result.email}")
    print(f"State: {result.state}")      # 'deliverable', 'undeliverable', 'risky', 'unknown'
    print(f"Score: {result.score}")      # 0-100
    print(f"Reason: {result.reason}")    # Why this verdict was given
    print(f"Full Result: {result}")
except Exception as e:
    print(f"Verification failed: {e}")
```

Run it:

```bash
python verify_email.py
```
</Tab>

<Tab value="Go">
Create a file called `main.go`:

```go
package main

import (
    "bytes"
    "encoding/json"
    "fmt"
    "io"
    "net/http"
)

func main() {
    // Prepare the request body
    requestBody, _ := json.Marshal(map[string]string{
        "email": "test@gmail.com",
    })

    // Create the request
    req, err := http.NewRequest("POST", "https://verifio.email/api/verify/v1/email", bytes.NewBuffer(requestBody))
    if err != nil {
        fmt.Println("Error creating request:", err)
        return
    }

    // Set headers
    req.Header.Set("Authorization", "Bearer YOUR_API_KEY")  // Replace with your actual key
    req.Header.Set("Content-Type", "application/json")

    // Send the request
    client := &http.Client{}
    resp, err := client.Do(req)
    if err != nil {
        fmt.Println("Error sending request:", err)
        return
    }
    defer resp.Body.Close()

    // Read the response
    body, _ := io.ReadAll(resp.Body)
    fmt.Println("Response:", string(body))
}
```

Run it:

```bash
go run main.go
```
</Tab>

<Tab value="PHP">
Create a file called `verify_email.php`:

```php
<?php

$apiKey = 'YOUR_API_KEY';  // Replace with your actual key
$email = 'test@gmail.com';

$ch = curl_init();

curl_setopt($ch, CURLOPT_URL, 'https://verifio.email/api/verify/v1/email');
curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
curl_setopt($ch, CURLOPT_POST, true);
curl_setopt($ch, CURLOPT_HTTPHEADER, [
    'Authorization: Bearer ' . $apiKey,
    'Content-Type: application/json'
]);
curl_setopt($ch, CURLOPT_POSTFIELDS, json_encode([
    'email' => $email
]));

$response = curl_exec($ch);
$httpCode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

if (curl_errno($ch)) {
    echo 'Error: ' . curl_error($ch);
} else {
    echo "HTTP Code: $httpCode\n";
    echo "Response: $response\n";
    
    // Parse and display the result
    $result = json_decode($response, true);
    if ($result['success']) {
        echo "Email: " . $result['data']['email'] . "\n";
        echo "State: " . $result['data']['state'] . "\n";
        echo "Score: " . $result['data']['score'] . "\n";
    }
}

curl_close($ch);
```

Run it:

```bash
php verify_email.php
```
</Tab>

</Tabs>
</Step>

<Step>
### Step 4: Understanding the Response

A successful verification returns a JSON response like this:

```json
{
  "success": true,
  "data": {
    "email": "test@gmail.com",
    "user": "test",
    "domain": "gmail.com",
    "tag": null,
    "state": "deliverable",
    "reason": "valid_mailbox",
    "score": 95,
    "checks": {
      "syntax": { "valid": true },
      "dns": { 
        "valid": true, 
        "domainExists": true,
        "hasMx": true, 
        "mxRecords": ["alt1.gmail-smtp-in.l.google.com", "..."],
        "preferredMx": "alt1.gmail-smtp-in.l.google.com"
      },
      "disposable": { "isDisposable": false },
      "role": { "isRole": false },
      "freeProvider": { "isFree": true, "provider": "gmail" },
      "typo": { "hasTypo": false },
      "smtp": { "valid": true, "mailboxExists": true, "isCatchAll": false }
    },
    "analytics": {
      "didYouMean": null,
      "domainAge": 8500,
      "smtpProvider": "Google",
      "riskLevel": "low",
      "qualityIndicators": ["established_domain", "major_provider"],
      "warnings": []
    },
    "duration": 1234,
    "verifiedAt": "2026-01-17T10:30:00.000Z"
  }
}
```

Let's break down what each field means:
</Step>

</Steps>

---

## Complete Response Reference

### Top-Level Fields

| Field | Type | Description |
|-------|------|-------------|
| `success` | `boolean` | `true` if the API call was successful, `false` if there was an error |
| `data` | `object` | The verification result (only present when `success` is `true`) |
| `error` | `string` | Error message (only present when `success` is `false`) |

### Core Identification Fields (`data.*`)

| Field | Type | Description |
|-------|------|-------------|
| `email` | `string` | The email address that was verified |
| `user` | `string` | The local part (everything before `@`) |
| `domain` | `string` | The domain part (everything after `@`) |
| `tag` | `string \| null` | Plus-addressing tag if present (e.g., `test+newsletter@gmail.com` ‚Üí `newsletter`) |

### Verdict Fields (`data.*`)

| Field | Type | Description |
|-------|------|-------------|
| `state` | `string` | Primary verdict: `deliverable`, `undeliverable`, `risky`, or `unknown` |
| `reason` | `string` | Specific reason code explaining the verdict |
| `score` | `number` | Quality score from 0-100 (higher = better) |

#### State Values Explained

| State | Meaning | What to Do |
|-------|---------|------------|
| `deliverable` | ‚úÖ Email is valid and will receive messages | Safe to send emails |
| `undeliverable` | ‚ùå Email is invalid or doesn't exist | Do NOT send - will bounce |
| `risky` | ‚ö†Ô∏è Email exists but has quality concerns | Use caution - may bounce or be low engagement |
| `unknown` | ‚ùì Could not determine validity | Retry later or use with caution |

#### Reason Codes Explained

**For Deliverable Emails:**
| Reason | Meaning |
|--------|---------|
| `valid_mailbox` | Mailbox exists and accepts messages |
| `accepted_email` | SMTP server accepted the email |

**For Undeliverable Emails:**
| Reason | Meaning |
|--------|---------|
| `invalid_syntax` | Email format is wrong (e.g., missing `@`) |
| `invalid_domain` | Domain doesn't exist |
| `no_mx_records` | Domain has no email servers configured |
| `mailbox_not_found` | The specific mailbox doesn't exist |
| `mailbox_full` | Mailbox is full (temporary) |

**For Risky Emails:**
| Reason | Meaning |
|--------|---------|
| `disposable_email` | Temporary/throwaway email provider |
| `role_based_email` | Generic address like `info@`, `support@` |
| `catch_all_domain` | Domain accepts all addresses |
| `free_email_provider` | Free provider (Gmail, Yahoo, etc.) |

**For Unknown Results:**
| Reason | Meaning |
|--------|---------|
| `timeout` | Server took too long to respond |
| `connection_error` | Network connectivity issue |
| `unknown_error` | Unexpected error occurred |

---

## Understanding the Checks Object

The `checks` object contains detailed results from each verification step:

### Syntax Check (`checks.syntax`)

Validates that the email address is properly formatted.

```json
{
  "valid": true,
  "error": "Optional error message if invalid"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `valid` | `boolean` | `true` if email syntax is correct |
| `error` | `string` | Specific syntax error if invalid |

### DNS Check (`checks.dns`)

Checks if the domain exists and has mail servers.

```json
{
  "valid": true,
  "domainExists": true,
  "hasMx": true,
  "mxRecords": ["mail.example.com", "mail2.example.com"],
  "preferredMx": "mail.example.com"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `valid` | `boolean` | Overall DNS check passed |
| `domainExists` | `boolean` | Domain has DNS records |
| `hasMx` | `boolean` | Domain has MX (mail exchange) records |
| `mxRecords` | `string[]` | List of mail server hostnames |
| `preferredMx` | `string` | Highest priority mail server |

### Disposable Check (`checks.disposable`)

Detects temporary/throwaway email services.

```json
{
  "isDisposable": false,
  "provider": "tempmail"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `isDisposable` | `boolean` | `true` if email is from a disposable provider |
| `provider` | `string` | Name of the disposable service (if detected) |

### Role Check (`checks.role`)

Detects generic/role-based addresses.

```json
{
  "isRole": true,
  "role": "support"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `isRole` | `boolean` | `true` if email is role-based (info@, admin@, etc.) |
| `role` | `string` | The detected role (support, admin, sales, etc.) |

### Free Provider Check (`checks.freeProvider`)

Detects free email providers.

```json
{
  "isFree": true,
  "provider": "gmail"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `isFree` | `boolean` | `true` if from a free provider |
| `provider` | `string` | Name of the provider (gmail, yahoo, outlook, etc.) |

### Typo Check (`checks.typo`)

Detects common typos and suggests corrections.

```json
{
  "hasTypo": true,
  "suggestion": "user@gmail.com",
  "originalDomain": "gmial.com",
  "suggestedDomain": "gmail.com"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `hasTypo` | `boolean` | `true` if a typo was detected |
| `suggestion` | `string` | Corrected email address |
| `originalDomain` | `string` | The domain with the typo |
| `suggestedDomain` | `string` | The suggested correct domain |

### SMTP Check (`checks.smtp`)

Verifies with the actual mail server.

```json
{
  "valid": true,
  "mailboxExists": true,
  "isCatchAll": false,
  "response": "250 OK"
}
```

| Field | Type | Description |
|-------|------|-------------|
| `valid` | `boolean \| null` | SMTP check passed (`null` if skipped) |
| `mailboxExists` | `boolean \| null` | Mailbox definitely exists |
| `isCatchAll` | `boolean \| null` | Domain accepts all addresses |
| `response` | `string` | Raw SMTP server response |

---

## Understanding the Analytics Object

The `analytics` object provides advanced insights:

```json
{
  "didYouMean": null,
  "domainAge": 8500,
  "smtpProvider": "Google",
  "riskLevel": "low",
  "qualityIndicators": ["established_domain", "major_provider"],
  "warnings": []
}
```

| Field | Type | Description |
|-------|------|-------------|
| `didYouMean` | `string \| null` | Suggested correction for typos |
| `domainAge` | `number \| null` | Domain age in days |
| `smtpProvider` | `string \| null` | Detected email provider |
| `riskLevel` | `string` | Risk assessment: `low`, `medium`, or `high` |
| `qualityIndicators` | `string[]` | Positive signals about the email |
| `warnings` | `string[]` | Potential issues to be aware of |

---

## Request Body Options

You can customize the verification by passing options:

```json
{
  "email": "user@example.com",
  "options": {
    "skipDisposable": false,
    "skipRole": false,
    "skipTypo": false
  }
}
```

| Option | Type | Default | Description |
|--------|------|---------|-------------|
| `skipDisposable` | `boolean` | `false` | Skip the disposable email check |
| `skipRole` | `boolean` | `false` | Skip the role-based email check |
| `skipTypo` | `boolean` | `false` | Skip the typo detection check |

<Callout>
  Skipping checks can speed up verification but provides less comprehensive results. Only skip if you have specific reasons (e.g., you explicitly allow disposable emails).
</Callout>

---

## Error Handling

### HTTP Status Codes

| Code | Meaning | Action |
|------|---------|--------|
| `200` | Success | Parse the response |
| `400` | Bad Request | Check your request body format |
| `401` | Unauthorized | Check your API key |
| `402` | Payment Required | Insufficient credits |
| `429` | Rate Limited | Wait and retry |
| `500` | Server Error | Retry after a moment |

### Error Response Format

```json
{
  "success": false,
  "error": "Description of what went wrong",
  "retryAfter": 60
}
```

### Handling Errors in Code

<Tabs items={['Node.js', 'Python', 'cURL']}>

<Tab value="Node.js">
```javascript
try {
  const result = await verifio.verify('test@example.com');
  
  if (result.state === 'deliverable') {
    console.log('‚úÖ Safe to send');
  } else if (result.state === 'undeliverable') {
    console.log('‚ùå Do not send');
  } else if (result.state === 'risky') {
    console.log('‚ö†Ô∏è Proceed with caution');
    console.log('Warnings:', result.analytics.warnings);
  } else {
    console.log('‚ùì Unknown - retry later');
  }
} catch (error) {
  if (error.status === 401) {
    console.error('Invalid API key');
  } else if (error.status === 402) {
    console.error('No credits remaining');
  } else if (error.status === 429) {
    const retryAfter = error.retryAfter || 60;
    console.error(`Rate limited. Retry in ${retryAfter} seconds`);
  } else {
    console.error('Unexpected error:', error.message);
  }
}
```
</Tab>

<Tab value="Python">
```python
from verifio import Verifio
from verifio.exceptions import AuthenticationError, RateLimitError, InsufficientCreditsError

client = Verifio(api_key='YOUR_API_KEY')

try:
    result = client.verify('test@example.com')
    
    if result.state == 'deliverable':
        print('‚úÖ Safe to send')
    elif result.state == 'undeliverable':
        print('‚ùå Do not send')
    elif result.state == 'risky':
        print('‚ö†Ô∏è Proceed with caution')
        print('Warnings:', result.analytics.warnings)
    else:
        print('‚ùì Unknown - retry later')
        
except AuthenticationError:
    print('Invalid API key')
except InsufficientCreditsError:
    print('No credits remaining')
except RateLimitError as e:
    print(f'Rate limited. Retry in {e.retry_after} seconds')
except Exception as e:
    print(f'Unexpected error: {e}')
```
</Tab>

<Tab value="cURL">
```bash
# Check the HTTP status code
response=$(curl -s -w "\n%{http_code}" -X POST "https://verifio.email/api/verify/v1/email" \
  -H "Authorization: Bearer YOUR_API_KEY" \
  -H "Content-Type: application/json" \
  -d '{"email": "test@example.com"}')

# Extract body and status code
body=$(echo "$response" | head -n -1)
status_code=$(echo "$response" | tail -n 1)

echo "Status Code: $status_code"
echo "Response: $body"

# Handle different status codes
case $status_code in
  200)
    echo "Success!"
    ;;
  401)
    echo "Error: Invalid API key"
    ;;
  402)
    echo "Error: Insufficient credits"
    ;;
  429)
    echo "Error: Rate limited. Wait and retry."
    ;;
  *)
    echo "Error: Unexpected status code $status_code"
    ;;
esac
```
</Tab>

</Tabs>

---

## Score Interpretation Guide

The `score` field (0-100) gives you a quick quality assessment:

| Score Range | Quality | Recommendation |
|-------------|---------|----------------|
| **90-100** | Excellent | ‚úÖ Safe to send, high deliverability |
| **70-89** | Good | ‚úÖ Generally safe, minor concerns possible |
| **50-69** | Fair | ‚ö†Ô∏è Some risk factors, monitor bounce rates |
| **30-49** | Poor | ‚ö†Ô∏è High risk, consider not sending |
| **0-29** | Very Poor | ‚ùå Very high bounce risk, do not send |

---

## Best Practices

### 1. Store Your API Key Securely

**Never hardcode API keys in your source code.** Use environment variables:

<Tabs items={['Node.js', 'Python', 'Bash']}>

<Tab value="Node.js">
```javascript
// Create a .env file
// VERIFIO_API_KEY=vrf_sk_live_xxx

import { Verifio } from '@verifio/email-verification';

const verifio = new Verifio({
  apiKey: process.env.VERIFIO_API_KEY
});
```
</Tab>

<Tab value="Python">
```python
# Create a .env file
# VERIFIO_API_KEY=vrf_sk_live_xxx

import os
from verifio import Verifio

client = Verifio(api_key=os.environ['VERIFIO_API_KEY'])
```
</Tab>

<Tab value="Bash">
```bash
# Add to your ~/.bashrc or ~/.zshrc
export VERIFIO_API_KEY="vrf_sk_live_xxx"

# Then use in scripts
curl -H "Authorization: Bearer $VERIFIO_API_KEY" ...
```
</Tab>

</Tabs>

### 2. Implement Retry Logic

For `429 Rate Limited` and `5xx` errors, implement exponential backoff:

```javascript
async function verifyWithRetry(email, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await verifio.verify(email);
    } catch (error) {
      if (error.status === 429 || error.status >= 500) {
        const waitTime = Math.pow(2, attempt) * 1000; // 2s, 4s, 8s
        console.log(`Attempt ${attempt} failed. Retrying in ${waitTime}ms...`);
        await new Promise(resolve => setTimeout(resolve, waitTime));
      } else {
        throw error; // Don't retry client errors (4xx)
      }
    }
  }
  throw new Error('Max retries exceeded');
}
```

### 3. Handle All States

Always handle all four possible states in your code:

```javascript
switch (result.state) {
  case 'deliverable':
    // Proceed with email sending
    break;
  case 'undeliverable':
    // Block the email, show error to user
    break;
  case 'risky':
    // Warn user, or collect anyway with a flag
    break;
  case 'unknown':
    // Retry later or collect with manual review
    break;
}
```

### 4. Use Typo Suggestions

If `checks.typo.hasTypo` is `true`, offer the user a suggestion:

```javascript
if (result.checks.typo.hasTypo) {
  const suggestion = result.checks.typo.suggestion;
  // Show to user: "Did you mean user@gmail.com instead of user@gmial.com?"
}
```

---

## Common Use Cases

### Form Validation

```javascript
// Validate email on signup form
app.post('/signup', async (req, res) => {
  const { email, password } = req.body;
  
  const verification = await verifio.verify(email);
  
  if (verification.state === 'undeliverable') {
    return res.status(400).json({
      error: 'Please enter a valid email address',
      suggestion: verification.checks.typo.suggestion
    });
  }
  
  if (verification.checks.disposable.isDisposable) {
    return res.status(400).json({
      error: 'Please use a permanent email address, not a temporary one'
    });
  }
  
  // Proceed with signup...
});
```

### CRM Data Cleaning

```javascript
// Verify existing contacts
for (const contact of contacts) {
  const result = await verifio.verify(contact.email);
  
  await updateContact(contact.id, {
    emailVerified: result.state === 'deliverable',
    emailScore: result.score,
    emailRiskLevel: result.analytics.riskLevel
  });
}
```

---

## Rate Limits

| Authentication | Rate Limit |
|----------------|------------|
| Without API Key | 2 requests/minute per IP |
| With API Key | Based on your plan |

<Callout type="warn">
  **Exceeding rate limits returns HTTP 429.** The response includes a `retryAfter` field (in seconds) telling you when you can retry.
</Callout>

---

## Next Steps

<Cards>
  <Card 
    title="Bulk Verification" 
    description="Verify thousands of emails at once"
    href="/docs/guides/setup/backend/postApiVerifyV1Bulk" 
  />
  <Card 
    title="Authentication Guide" 
    description="Learn about API key management and security"
    href="/docs/guides/getting-started/authentication" 
  />
  <Card 
    title="SDKs & Libraries" 
    description="Official SDKs for Node.js, Python, Go, and more"
    href="/docs/guides/sdks/overview" 
  />
</Cards>

---

## Need Help?

- üìß **Email Support:** support@verifio.email
- üí¨ **Discord Community:** [Join our Discord](https://discord.gg/verifio)
- üìö **GitHub Issues:** [Report bugs or suggest features](https://github.com/reloop-labs/verifio)
