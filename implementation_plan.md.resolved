# Verifio Application Security Audit Report

This is a comprehensive security audit and modernization assessment of the Verifio application covering backend services, APIs, authentication, authorization, infrastructure, and configuration.

> [!CAUTION]
> This report contains **critical security vulnerabilities** that must be addressed before production deployment. Several issues could lead to data breaches, financial loss, or complete system compromise.

---

## 1. Critical Issues (Must Fix Before Deployment)

### 1.1 API Keys Stored in Plaintext ðŸ”´
**Location**: [api-key.ts](file:///Users/twinkal/Development/verifio/packages/db/src/schema/api-key.ts#L16), [create-api-key.ts](file:///Users/twinkal/Development/verifio/apps/backend/api-key/src/routes/api-key/controllers/create-api-key.ts#L56)

**Problem**: API keys are stored as plaintext in the database (`key: text("key").notNull()`). The full key is inserted directly without hashing.

```typescript
// create-api-key.ts:56 - Stores plaintext key
key: fullKey,
```

**Risk**: If the database is compromised (SQL injection, backup leak, insider threat), all API keys are immediately usable by attackers.

**Fix**: 
- Hash API keys using bcrypt/PBKDF2 before storage
- Only store the hash, display the key once on creation
- Keep only the key prefix for lookup/display (`start` field already exists)

---

### 1.2 API Key Validation Uses Plaintext Comparison ðŸ”´
**Location**: [auth.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/middleware/auth.ts#L54-L58)

**Problem**: API key validation queries the database with the raw key for direct comparison:

```typescript
const result = await db.query.apikey.findFirst({
  where: and(
    eq(schema.apikey.key, apiKey), // Plaintext comparison
    eq(schema.apikey.enabled, true),
  ),
});
```

**Risk**: Timing attacks, plaintext key exposure in database logs/query monitors.

**Fix**: 
- Look up by prefix, then use constant-time comparison of hashes
- Use a timing-safe comparison function like `crypto.timingSafeEqual`

---

### 1.3 Hardcoded Internal Service Secrets ðŸ”´
**Location**: [config.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/config.ts#L12), [credits.config.ts](file:///Users/twinkal/Development/verifio/apps/backend/credits/src/credits.config.ts#L10)

**Problem**: Internal service-to-service authentication uses a hardcoded default secret:

```typescript
INTERNAL_SERVICE_SECRET: "internal-secret" // Hardcoded default!
```

**Risk**: Anyone with access to the source code can bypass internal service authentication. This secret is the same across verify/credits services.

**Fix**:
- Remove all hardcoded defaults for secrets
- Require `INTERNAL_SERVICE_SECRET` as mandatory in production
- Generate cryptographically random secrets (32+ bytes, base64 encoded)
- Rotate secrets periodically

---

### 1.4 JWKS Private Keys Stored Unencrypted ðŸ”´
**Location**: [auth.ts](file:///Users/twinkal/Development/verifio/packages/db/src/schema/auth.ts#L67)

**Problem**: JWKS private keys are stored as plaintext in the database:

```typescript
privateKey: text("private_key").notNull(),
```

**Risk**: Database compromise exposes JWT signing keys, enabling token forgery for any user.

**Fix**:
- Encrypt private keys at rest using envelope encryption
- Use AWS KMS, GCP KMS, or HashiCorp Vault for key management
- Consider HSM for production environments

---

### 1.5 Credits Bypass on Service Failure ðŸ”´
**Location**: [credits-client.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/services/credits-client.ts#L63-L68)

**Problem**: When the credits service is unavailable, the system grants unlimited credits:

```typescript
} catch (error) {
  // Return success with credits available to avoid blocking
  return {
    success: true,
    data: { hasCredits: true, remaining: 9999, required: amount },
  };
}
```

**Risk**: 
- Attackers can DoS the credits service to get unlimited free verifications
- Billing integrity completely compromised during any outage
- Financial loss from unbilled usage

**Fix**:
- Fail closed: deny requests if credits can't be verified
- Implement circuit breaker pattern with fallback to cached credit state
- Alert on credits service failures immediately

---

### 1.6 OAuth Tokens Stored Unencrypted ðŸ”´
**Location**: [auth.ts](file:///Users/twinkal/Development/verifio/packages/db/src/schema/auth.ts#L33-L35)

**Problem**: OAuth access tokens, refresh tokens, and ID tokens stored as plaintext:

```typescript
accessToken: text("access_token"),
refreshToken: text("refresh_token"),
idToken: text("id_token"),
```

**Risk**: Database breach exposes all OAuth tokens, allowing account takeover on connected services (Google, GitHub accounts).

**Fix**:
- Encrypt tokens at rest using application-level encryption
- Use a dedicated secrets manager
- Consider not storing tokens if not needed for ongoing API access

---

## 2. High-Risk Issues

### 2.1 CORS Completely Open in Verify Service ðŸŸ 
**Location**: [index.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/index.ts#L27)

**Problem**: CORS is configured to accept any origin:

```typescript
.use(
  cors({
    origin: true, // Accepts ANY origin
    methods: ["GET", "POST", "OPTIONS"],
    allowedHeaders: ["Content-Type", "X-API-Key", "Authorization", "Cookie"],
    credentials: true,
  }),
)
```

**Risk**: 
- Cross-origin attacks from any website
- Cookie-based session theft via malicious sites
- CSRF attacks when `credentials: true`

**Fix**:
- Whitelist specific origins like auth service does:
```typescript
origin: config.isProduction
  ? ["https://verifio.email", "https://www.verifio.email"]
  : ["http://localhost:3000"],
```

---

### 2.2 Public Bulk Jobs Without Authorization Check ðŸŸ 
**Location**: [bulk.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/routes/bulk.ts#L241-L280)

**Problem**: Public bulk job status/results endpoints don't verify the requester created the job:

```typescript
.get("/jobs/:jobId", ({ params }) => {
  const job = jobs.get(params.jobId); // Anyone can access any job!
  if (!job) return { success: false, error: "Job not found" };
  // Returns job data without auth check
})
```

**Risk**: Enumeration of job IDs exposes email lists and verification results of other users.

**Fix**:
- Track IP/session that created the job
- Require matching IP/token to access job results
- Use cryptographically random, unguessable job IDs (already using CUID2)
- Add rate limiting on job status lookups

---

### 2.3 In-Memory Job Storage with No Cleanup ðŸŸ 
**Location**: [bulk.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/routes/bulk.ts#L21-L33)

**Problem**: Jobs stored in a Map without cleanup:

```typescript
const jobs = new Map<string, { ... }>();
// Comment: "for demo - use database in production"
```

**Risk**:
- Memory exhaustion DoS - attackers can create unlimited jobs
- Jobs lost on server restart
- No horizontal scalability

**Fix**:
- Move to database or Redis with TTL
- Implement job cleanup after expiration
- Add limits on concurrent jobs per IP

---

### 2.4 Rate Limit Check-Then-Act Race Condition ðŸŸ 
**Location**: [rate-limit.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/middleware/rate-limit.ts#L52-L82)

**Problem**: Rate limiting uses non-atomic get-then-set operations:

```typescript
const entry = await redis.get<RateLimitEntry>(key);
// ... check entry.count ...
await redis.set(key, { count: entry.count + 1, ... });
```

**Risk**: Concurrent requests can bypass rate limits via race condition.

**Fix**:
- Use Redis INCR or Lua script for atomic increment
- Consider Redis `SETNX` or `SET NX EX` for sliding window

---

### 2.5 TLS Certificate Verification Disabled ðŸŸ 
**Location**: [auth.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/middleware/auth.ts#L15-L17), [auth.ts](file:///Users/twinkal/Development/verifio/apps/backend/credits/src/middleware/auth.ts#L11-L12)

**Problem**: TLS verification disabled in non-production:

```typescript
if (verifyConfig.environment !== "production") {
  process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";
}
```

**Risk**:
- MITM attacks in development/staging environments
- Credential theft when connecting to auth service
- Bad security habits that may leak to production

**Fix**:
- Use proper CA certificates for local development
- Use mkcert for local HTTPS development
- Never disable TLS verification programmatically

---

### 2.6 Trusted Origins Wildcard in Development ðŸŸ 
**Location**: [auth.ts](file:///Users/twinkal/Development/verifio/apps/backend/auth/src/lib/auth.ts#L149-L154)

**Problem**: All origins trusted in development:

```typescript
trustedOrigins: authConfig.isProduction
  ? ["https://verifio.email", "https://www.verifio.email"]
  : ["*"], // Wildcard in dev
```

**Risk**: Development environments can be attacked if exposed.

**Fix**:
- Explicitly list development origins: `["http://localhost:3000"]`
- Never use wildcards

---

## 3. Medium / Long-Term Risks

### 3.1 TOCTOU Race in Credit Check+Deduct Flow ðŸŸ¡
**Location**: [authenticated.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/routes/authenticated.ts#L163-L180), [authenticated.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/routes/authenticated.ts#L228)

**Problem**: Credit check and deduction are separate operations:

```typescript
// Step 1: Check credits
const creditCheck = await checkCredits(organizationId, 1);
// ... verification happens ...
// Step 2: Deduct credits (later)
const deductResult = await deductCredits(organizationId, 1);
```

**Risk**: Concurrent requests can pass the check simultaneously, then all try to deduct, potentially over-spending.

**Fix**: Use atomic deduction only (deductCredits already handles this with SQL WHERE), but consider:
- Reserve credits upfront with timeout
- Use distributed locking for critical sections

---

### 3.2 Randomized Auth Secret in Development ðŸŸ¡
**Location**: [auth.config.ts](file:///Users/twinkal/Development/verifio/apps/backend/auth/src/auth.config.ts#L28)

**Problem**: Development auth secret includes random data:

```typescript
BETTER_AUTH_SECRET: `dev-secret-change-in-production-${Math.random()}`,
```

**Risk**: 
- Sessions invalidated on every server restart
- Inconsistent behavior across dev environments
- Debugging sessions becomes difficult

**Fix**: Use a fixed development secret (still different from production).

---

### 3.3 Email Logging May Expose PII ðŸŸ¡
**Location**: [authenticated.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/routes/authenticated.ts#L183-L186)

**Problem**: Full email addresses logged:

```typescript
logger.info(
  { email: body.email, organizationId, userId },
  "Verifying single email (authenticated)",
);
```

**Risk**: PII in logs violates GDPR/privacy requirements.

**Fix**:
- Hash or truncate emails in logs: `email: hash(body.email).slice(0,12)`
- Use structured logging with PII redaction

---

### 3.4 Password Reset Token Logged in Development ðŸŸ¡
**Location**: [auth.ts](file:///Users/twinkal/Development/verifio/apps/backend/auth/src/lib/auth.ts#L110-L113)

**Problem**: Reset tokens logged:

```typescript
if (authConfig.NODE_ENV === "development") {
  logger.info("Reset URL (DEV):", url);
  logger.info("Token (DEV):", token);
}
```

**Risk**: Token exposure in development logs that may be shared/persisted.

**Fix**: Remove token logging entirely, only log that reset was requested.

---

### 3.5 Missing Input Validation on Email Field ðŸŸ¡
**Location**: [authenticated.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/routes/authenticated.ts#L29-L33)

**Problem**: Authenticated route has less strict validation than public:

```typescript
// Authenticated route - no format validation
email: t.String({ minLength: 1, maxLength: 254 })

// Public route (single.ts) - has format validation
email: t.String({ format: "email", minLength: 1, maxLength: 254 })
```

**Risk**: Invalid emails bypass format validation in authenticated routes.

**Fix**: Add `format: "email"` to all email input schemas.

---

## 4. Minor but Important Improvements

### 4.1 Health Endpoint Information Disclosure ðŸ”µ
**Location**: [landing.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/routes/landing.ts#L20-L35)

**Problem**: Health endpoints expose error details:

```typescript
dbError = dbErr instanceof Error ? dbErr.message : String(dbErr);
```

**Risk**: Database/Redis error messages may reveal internal structure.

**Fix**: Log errors server-side, return generic status to clients.

---

### 4.2 Missing Request Timeout ðŸ”µ
**Location**: [credits-client.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/services/credits-client.ts)

**Problem**: No timeout on internal service calls:

```typescript
const response = await fetch(url, { ... }); // No timeout
```

**Risk**: Hanging requests can exhaust connection pools.

**Fix**: Add `AbortController` with timeout:
```typescript
const controller = new AbortController();
setTimeout(() => controller.abort(), 5000);
```

---

### 4.3 API Key Service Missing CORS Configuration ðŸ”µ
**Location**: [index.ts](file:///Users/twinkal/Development/verifio/apps/backend/api-key/src/index.ts)

**Problem**: No CORS configuration visible in api-key service.

**Risk**: Either relies on default (may be permissive) or lacks needed CORS.

**Fix**: Explicitly configure CORS matching auth service pattern.

---

### 4.4 Organization Member Role Not Verified for API Operations ðŸ”µ
**Location**: [authenticated.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/routes/authenticated.ts#L154)

**Problem**: Uses `organizationId` from auth context but doesn't verify user's role:

```typescript
async ({ body, organizationId, userId, apiKeyId, request, set }) => {
  // Uses organizationId directly, no role check
```

**Risk**: Any org member might perform operations that should be admin-only.

**Fix**: Verify member role for sensitive operations.

---

### 4.5 Missing API Key Permissions Enforcement ðŸ”µ
**Location**: [auth.ts](file:///Users/twinkal/Development/verifio/apps/backend/verify/src/middleware/auth.ts#L88-L92)

**Problem**: API key has `permissions` field but no enforcement:

```typescript
return {
  organizationId: result.organizationId,
  userId: result.userId,
  apiKeyId: result.id,
  // permissions not checked or returned!
};
```

**Fix**: Return and enforce permissions for granular access control.

---

## 5. Missing Checks, Assumptions, or Implicit Trust

| Area | Issue | Risk |
|------|-------|------|
| **Organization Access** | No verification user belongs to organization via membership | IDOR vulnerability |
| **API Key Ownership** | When validating API key, no check key's user still has org access | Revoked users retain access |
| **Credits Deduction** | Verification succeeds even if deduction fails | Billing integrity issue |
| **Session Refresh** | No explicit check for revoked sessions | Logged out users may retain access |
| **Rate Limit Bypass** | Rate limiting based on IP only | Easily bypassed with proxies |
| **Bulk Job Isolation** | Public bulk jobs not isolated by creator | Job enumeration attack |
| **Internal Network** | Services assume internal network is trusted | No mutual TLS between services |
| **Error Messages** | Specific error messages for "key not found" vs "key disabled" | Enumeration attack |

---

## 6. Production-Grade Recommendations

### 6.1 Immediate Actions (Before Go-Live)
1. âœ… Hash API keys before storage
2. âœ… Remove hardcoded secrets, require env vars in production
3. âœ… Fix credits bypass - fail closed
4. âœ… Encrypt sensitive fields (OAuth tokens, JWKS private keys)
5. âœ… Configure CORS properly for verify service
6. âœ… Add authorization to public bulk job endpoints

### 6.2 Short-Term Improvements (First Month)
1. Implement atomic rate limiting
2. Move bulk jobs to persistent storage
3. Add request timeouts to all internal calls
4. Implement proper role-based access control
5. Add audit logging for security events
6. Remove sensitive data from logs

### 6.3 Infrastructure Recommendations
1. **Secrets Management**: Use HashiCorp Vault or cloud KMS
2. **Network Security**: Implement mutual TLS between services
3. **Monitoring**: Add alerting for auth failures, rate limit hits
4. **Database**: Enable encrypted connections, audit logging
5. **Redis**: Enable AUTH, TLS, and configure maxmemory policies
6. **CI/CD**: Add security scanning (SAST, dependency audit)

### 6.4 Operational Security
1. Implement secret rotation procedures
2. Create incident response runbook
3. Document security architecture
4. Schedule regular security reviews
5. Implement penetration testing before major releases

---

## Verification Plan

### Automated Verification
Since this is a security audit (read-only assessment), there are no code changes to test. However, these issues can be confirmed by:

1. **Database inspection**: Query `apikey` table to confirm keys are plaintext
2. **Network inspection**: Test CORS headers with `curl -v`
3. **Log review**: Search logs for email addresses / tokens
4. **Config review**: Grep for hardcoded secrets

### Manual Verification by User
After fixes are implemented:
1. Create API key and verify only hash is stored
2. Attempt cross-origin request to verify CORS enforcement
3. Test credits service failure handling
4. Verify rate limiting under concurrent load

---

> [!IMPORTANT]
> This audit identified **6 critical issues** that must be fixed before any production deployment. The most severe are plaintext API key storage and the credits bypass vulnerability, which together could result in complete financial loss and unauthorized access.
